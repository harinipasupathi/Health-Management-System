Creation of Tables:
 -- Table for storing patient information
CREATE TABLE Patients (
    Patient_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    First_Name VARCHAR2(50) NOT NULL,
    Last_Name VARCHAR2(50) NOT NULL,
    Date_Of_Birth DATE NOT NULL,
    Gender VARCHAR2(10),
    Phone_Number VARCHAR2(15),
    Email VARCHAR2(100),
    Address VARCHAR2(255),
    Created_At TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table for storing doctor information
CREATE TABLE Doctors (
    Doctor_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    First_Name VARCHAR2(50) NOT NULL,
    Last_Name VARCHAR2(50) NOT NULL,
    Specialty VARCHAR2(100),
    Phone_Number VARCHAR2(15),
    Email VARCHAR2(100),
    Created_At TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table for storing appointment details
CREATE TABLE Appointments (
    Appointment_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Patient_ID NUMBER NOT NULL,
    Doctor_ID NUMBER NOT NULL,
    Appointment_Date DATE NOT NULL,
    Appointment_Time TIMESTAMP NOT NULL,
    Status VARCHAR2(20) DEFAULT 'Scheduled',
    Reason VARCHAR2(255),
    Created_At TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (Patient_ID) REFERENCES Patients(Patient_ID),
    FOREIGN KEY (Doctor_ID) REFERENCES Doctors(Doctor_ID)
);

-- Table for storing billing information
CREATE TABLE Billing (
    Billing_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Appointment_ID NUMBER NOT NULL,
    Amount NUMBER(10, 2) NOT NULL,
    Payment_Status VARCHAR2(20) DEFAULT 'Pending',
    Payment_Method VARCHAR2(50),
    Created_At TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (Appointment_ID) REFERENCES Appointments(Appointment_ID)
);

-- Table for storing medical records
CREATE TABLE Medical_Records (
    Record_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Patient_ID NUMBER NOT NULL,
    Doctor_ID NUMBER NOT NULL,
    Record_Date DATE NOT NULL,
    Diagnosis VARCHAR2(255),
    Treatment VARCHAR2(255),
    Prescription VARCHAR2(255),
    Notes CLOB,
    Created_At TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (Patient_ID) REFERENCES Patients(Patient_ID),
    FOREIGN KEY (Doctor_ID) REFERENCES Doctors(Doctor_ID)
);

-- Table for user authentication (optional, if implementing custom authentication)
CREATE TABLE Users (
    User_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Username VARCHAR2(50) UNIQUE NOT NULL,
    Password VARCHAR2(255) NOT NULL,
    Role VARCHAR2(50),
    Created_At TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

To enhance the functionality of the Health Management System (HMS) in Oracle, we can create triggers and procedures for automating tasks and enforcing business rules. Below, I’ve outlined some examples of triggers and procedures that could be useful in such a system:

 Triggers

1. Trigger to Automatically Update Appointment Status After Appointment Date:
   This trigger updates the appointment status to 'Completed' automatically after the appointment date and time have passed.

   CREATE OR REPLACE TRIGGER Update_Appointment_Status
   AFTER INSERT OR UPDATE ON Appointments
   FOR EACH ROW
   WHEN (NEW.Appointment_Date + NEW.Appointment_Time < SYSDATE)
   BEGIN
       UPDATE Appointments
       SET Status = 'Completed'
       WHERE Appointment_ID = :NEW.Appointment_ID;
   END;
   

2. Trigger to Log Changes in Patient Details:
   This trigger logs any updates made to the patient details into a separate audit table.

   -- Audit Table for Patient Changes
   CREATE TABLE Patient_Audit (
       Audit_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       Patient_ID NUMBER,
       Old_First_Name VARCHAR2(50),
       New_First_Name VARCHAR2(50),
       Old_Last_Name VARCHAR2(50),
       New_Last_Name VARCHAR2(50),
       Changed_At TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
       FOREIGN KEY (Patient_ID) REFERENCES Patients(Patient_ID)
   );

   -- Trigger to Log Changes in Patient Details
   CREATE OR REPLACE TRIGGER Log_Patient_Changes
   AFTER UPDATE ON Patients
   FOR EACH ROW
   BEGIN
       INSERT INTO Patient_Audit (Patient_ID, Old_First_Name, New_First_Name, Old_Last_Name, New_Last_Name)
       VALUES (:OLD.Patient_ID, :OLD.First_Name, :NEW.First_Name, :OLD.Last_Name, :NEW.Last_Name);
   END;
   

3. Trigger to Prevent Overlapping Appointments for the Same Doctor:
   This trigger checks if a doctor already has an appointment at the same time before inserting a new appointment.

   CREATE OR REPLACE TRIGGER Prevent_Overlapping_Appointments
   BEFORE INSERT OR UPDATE ON Appointments
   FOR EACH ROW
   DECLARE
       v_count NUMBER;
   BEGIN
       SELECT COUNT(*)
       INTO v_count
       FROM Appointments
       WHERE Doctor_ID = :NEW.Doctor_ID
       AND Appointment_Date = :NEW.Appointment_Date
       AND Appointment_Time = :NEW.Appointment_Time
       AND Status = 'Scheduled';

       IF v_count > 0 THEN
           RAISE_APPLICATION_ERROR(-20001, 'The doctor already has an appointment at the specified time.');
       END IF;
   END;
   

 Procedures

1. Procedure to Register a New Patient:
   This procedure inserts a new patient record and returns the new patient ID.

   CREATE OR REPLACE PROCEDURE Register_Patient(
       p_First_Name IN VARCHAR2,
       p_Last_Name IN VARCHAR2,
       p_Date_Of_Birth IN DATE,
       p_Gender IN VARCHAR2,
       p_Phone_Number IN VARCHAR2,
       p_Email IN VARCHAR2,
       p_Address IN VARCHAR2,
       p_Patient_ID OUT NUMBER
   ) AS
   BEGIN
       INSERT INTO Patients (First_Name, Last_Name, Date_Of_Birth, Gender, Phone_Number, Email, Address)
       VALUES (p_First_Name, p_Last_Name, p_Date_Of_Birth, p_Gender, p_Phone_Number, p_Email, p_Address)
       RETURNING Patient_ID INTO p_Patient_ID;
   END;
  
2. Procedure to Generate a Bill for an Appointment:
   This procedure generates a bill for a given appointment and updates the billing table.

   CREATE OR REPLACE PROCEDURE Generate_Bill(
       p_Appointment_ID IN NUMBER,
       p_Amount IN NUMBER,
       p_Payment_Method IN VARCHAR2,
       p_Billing_ID OUT NUMBER
   ) AS
   BEGIN
       INSERT INTO Billing (Appointment_ID, Amount, Payment_Method, Payment_Status)
       VALUES (p_Appointment_ID, p_Amount, p_Payment_Method, 'Pending')
       RETURNING Billing_ID INTO p_Billing_ID;
   END;
 
3. Procedure to Schedule an Appointment:
   This procedure schedules a new appointment and checks for any overlapping appointments for the doctor before inserting.

   CREATE OR REPLACE PROCEDURE Schedule_Appointment(
       p_Patient_ID IN NUMBER,
       p_Doctor_ID IN NUMBER,
       p_Appointment_Date IN DATE,
       p_Appointment_Time IN TIMESTAMP,
       p_Reason IN VARCHAR2,
       p_Appointment_ID OUT NUMBER
   ) AS
   BEGIN
       -- Check for overlapping appointments
       DECLARE
           v_count NUMBER;
       BEGIN
           SELECT COUNT(*)
           INTO v_count
           FROM Appointments
           WHERE Doctor_ID = p_Doctor_ID
           AND Appointment_Date = p_Appointment_Date
           AND Appointment_Time = p_Appointment_Time
           AND Status = 'Scheduled';

           IF v_count > 0 THEN
               RAISE_APPLICATION_ERROR(-20002, 'Overlapping appointment exists for the doctor.');
           ELSE
               INSERT INTO Appointments (Patient_ID, Doctor_ID, Appointment_Date, Appointment_Time, Status, Reason)
               VALUES (p_Patient_ID, p_Doctor_ID, p_Appointment_Date, p_Appointment_Time, 'Scheduled', p_Reason)
               RETURNING Appointment_ID INTO p_Appointment_ID;
           END IF;
       END;
   END;

In a Health Management System (HMS), PL/SQL functions can be used to encapsulate reusable logic, perform calculations, retrieve specific data, and validate information. Below are some examples of PL/SQL functions that can be applied within an HMS context:

Example Functions

1. Function to Calculate Patient Age:
   This function calculates the age of a patient based on their date of birth.

   CREATE OR REPLACE FUNCTION Get_Patient_Age(
       p_Patient_ID IN NUMBER
   ) RETURN NUMBER IS
       v_Date_Of_Birth DATE;
       v_Age NUMBER;
   BEGIN
       -- Retrieve the patient's date of birth
       SELECT Date_Of_Birth
       INTO v_Date_Of_Birth
       FROM Patients
       WHERE Patient_ID = p_Patient_ID;

       -- Calculate age
       v_Age := FLOOR(MONTHS_BETWEEN(SYSDATE, v_Date_Of_Birth) / 12);

       RETURN v_Age;
   EXCEPTION
       WHEN NO_DATA_FOUND THEN
           RETURN NULL; -- Return NULL if patient not found
   END Get_Patient_Age;
   ```

2. Function to Retrieve Doctor's Schedule:
   This function returns a list of scheduled appointments for a specific doctor on a given date.

   CREATE OR REPLACE FUNCTION Get_Doctor_Schedule(
       p_Doctor_ID IN NUMBER,
       p_Date IN DATE
   ) RETURN SYS_REFCURSOR IS
       v_Cursor SYS_REFCURSOR;
   BEGIN
       OPEN v_Cursor FOR
       SELECT Appointment_Time, Patient_ID, Status, Reason
       FROM Appointments
       WHERE Doctor_ID = p_Doctor_ID
       AND Appointment_Date = p_Date
       ORDER BY Appointment_Time;

       RETURN v_Cursor;
   END Get_Doctor_Schedule;

3. Function to Check Payment Status:
   This function checks if all payments for a given patient are completed.

   CREATE OR REPLACE FUNCTION Check_Payment_Status(
       p_Patient_ID IN NUMBER
   ) RETURN VARCHAR2 IS
       v_Count NUMBER;
   BEGIN
       -- Check for pending payments
       SELECT COUNT(*)
       INTO v_Count
       FROM Billing b
       JOIN Appointments a ON b.Appointment_ID = a.Appointment_ID
       WHERE a.Patient_ID = p_Patient_ID
       AND b.Payment_Status = 'Pending';

       IF v_Count = 0 THEN
           RETURN 'All Payments Completed';
       ELSE
           RETURN 'Pending Payments Exist';
       END IF;
   END Check_Payment_Status;
   
4. Function to Retrieve Patient Medical History:
   This function returns the medical history of a patient, including diagnoses and treatments.

   CREATE OR REPLACE FUNCTION Get_Patient_Medical_History(
       p_Patient_ID IN NUMBER
   ) RETURN SYS_REFCURSOR IS
       v_Cursor SYS_REFCURSOR;
   BEGIN
       OPEN v_Cursor FOR
       SELECT Record_Date, Diagnosis, Treatment, Prescription, Notes
       FROM Medical_Records
       WHERE Patient_ID = p_Patient_ID
       ORDER BY Record_Date DESC;

       RETURN v_Cursor;
   END Get_Patient_Medical_History;
 
5. Function to Calculate Total Billing Amount for a Patient:
   This function calculates the total billing amount for all completed appointments for a specific patient.

   ```sql
   CREATE OR REPLACE FUNCTION Get_Total_Billing_Amount(
       p_Patient_ID IN NUMBER
   ) RETURN NUMBER IS
       v_Total_Amount NUMBER;
   BEGIN
       -- Calculate the total billing amount
       SELECT SUM(b.Amount)
       INTO v_Total_Amount
       FROM Billing b
       JOIN Appointments a ON b.Appointment_ID = a.Appointment_ID
       WHERE a.Patient_ID = p_Patient_ID
       AND b.Payment_Status = 'Completed';

       RETURN NVL(v_Total_Amount, 0); -- Return 0 if no completed payments found
   END Get_Total_Billing_Amount;

6. Function to Check Available Slots for a Doctor:
   This function checks if a specific time slot is available for a doctor on a given date.

   CREATE OR REPLACE FUNCTION Check_Available_Slot(
       p_Doctor_ID IN NUMBER,
       p_Appointment_Date IN DATE,
       p_Appointment_Time IN TIMESTAMP
   ) RETURN VARCHAR2 IS
       v_Count NUMBER;
   BEGIN
       -- Check if the slot is available
       SELECT COUNT(*)
       INTO v_Count
       FROM Appointments
       WHERE Doctor_ID = p_Doctor_ID
       AND Appointment_Date = p_Appointment_Date
       AND Appointment_Time = p_Appointment_Time
       AND Status = 'Scheduled';

       IF v_Count = 0 THEN
           RETURN 'Available';
       ELSE
           RETURN 'Not Available';
       END IF;
   END Check_Available_Slot;

Incorporating advanced SQL techniques and PL/SQL packages in your Health Management System (HMS) can significantly enhance the functionality, performance, and maintainability of the application. Below, I'll outline the use of window functions and advanced SQL techniques along with the creation of a PL/SQL package to encapsulate various HMS-related operations.

Advanced SQL Techniques and Window Functions

Window functions in SQL are powerful tools for performing calculations across rows related to the current row without using GROUP BY. They are useful in scenarios such as ranking, running totals, moving averages, and other aggregations.

 Example of Window Functions in HMS

1. Calculating Running Total of Payments for a Patient:
   This SQL query calculates a running total of payments made by a patient over time using the `SUM()` window function.

   SELECT 
       Patient_ID,
       Billing_ID,
       Payment_Date,
       Amount,
       SUM(Amount) OVER (PARTITION BY Patient_ID ORDER BY Payment_Date) AS Running_Total
   FROM 
       Billing
   WHERE 
       Patient_ID = 1  -- Replace with the desired Patient_ID
   ORDER BY 
       Payment_Date;
  
2. Ranking Doctors by Number of Appointments:
   This query ranks doctors based on the number of appointments they have handled, using the `RANK()` window function.

   SELECT 
       Doctor_ID,
       First_Name,
       Last_Name,
       COUNT(Appointment_ID) AS Total_Appointments,
       RANK() OVER (ORDER BY COUNT(Appointment_ID) DESC) AS Doctor_Rank
   FROM 
       Doctors d
   JOIN 
       Appointments a ON d.Doctor_ID = a.Doctor_ID
   GROUP BY 
       Doctor_ID, First_Name, Last_Name
   ORDER BY 
       Doctor_Rank;


3. Calculating Average Appointment Duration for Each Doctor:
   This query calculates the average duration of appointments per doctor using the `AVG()` window function.

   SELECT 
       Doctor_ID,
       First_Name,
       Last_Name,
       AVG(Appointment_Duration) OVER (PARTITION BY Doctor_ID) AS Average_Duration
   FROM 
       (SELECT 
           a.Doctor_ID,
           d.First_Name,
           d.Last_Name,
           EXTRACT(MINUTE FROM (End_Time - Start_Time)) AS Appointment_Duration
        FROM 
           Appointments a
        JOIN 
           Doctors d ON a.Doctor_ID = d.Doctor_ID
        WHERE 
           a.Status = 'Completed') 
   ORDER BY 
       Doctor_ID;
 
Creating a PL/SQL Package for HMS

A PL/SQL package is a schema object that groups logically related PL/SQL types, items, and subprograms. Packages can help organize your code into modular, reusable components. Below is an example of a PL/SQL package for managing various operations within the HMS.

Package Specification (`HMS_PKG`)

This specification defines the interface for the package, including procedures, functions, and types.

CREATE OR REPLACE PACKAGE HMS_PKG IS
    -- Function to get patient details by ID
    FUNCTION Get_Patient_Details(p_Patient_ID IN NUMBER) RETURN SYS_REFCURSOR;

    -- Procedure to schedule an appointment
    PROCEDURE Schedule_Appointment(
        p_Patient_ID IN NUMBER,
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP,
        p_Reason IN VARCHAR2,
        p_Appointment_ID OUT NUMBER
    );

    -- Procedure to generate a bill
    PROCEDURE Generate_Bill(
        p_Appointment_ID IN NUMBER,
        p_Amount IN NUMBER,
        p_Payment_Method IN VARCHAR2,
        p_Billing_ID OUT NUMBER
    );

    -- Function to check available slots for a doctor
    FUNCTION Check_Available_Slot(
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP
    ) RETURN VARCHAR2;

END HMS_PKG;

 Package Body (`HMS_PKG`)

The body contains the implementation of the package specification.

CREATE OR REPLACE PACKAGE BODY HMS_PKG IS

    -- Function to get patient details
    FUNCTION Get_Patient_Details(p_Patient_ID IN NUMBER) RETURN SYS_REFCURSOR IS
        v_Cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_Cursor FOR
        SELECT *
        FROM Patients
        WHERE Patient_ID = p_Patient_ID;
        
        RETURN v_Cursor;
    END Get_Patient_Details;

    -- Procedure to schedule an appointment
    PROCEDURE Schedule_Appointment(
        p_Patient_ID IN NUMBER,
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP,
        p_Reason IN VARCHAR2,
        p_Appointment_ID OUT NUMBER
    ) IS
    BEGIN
        -- Check for overlapping appointments
        DECLARE
            v_count NUMBER;
        BEGIN
            SELECT COUNT(*)
            INTO v_count
            FROM Appointments
            WHERE Doctor_ID = p_Doctor_ID
            AND Appointment_Date = p_Appointment_Date
            AND Appointment_Time = p_Appointment_Time
            AND Status = 'Scheduled';

            IF v_count > 0 THEN
                RAISE_APPLICATION_ERROR(-20001, 'Overlapping appointment exists for the doctor.');
            ELSE
                INSERT INTO Appointments (Patient_ID, Doctor_ID, Appointment_Date, Appointment_Time, Status, Reason)
                VALUES (p_Patient_ID, p_Doctor_ID, p_Appointment_Date, p_Appointment_Time, 'Scheduled', p_Reason)
                RETURNING Appointment_ID INTO p_Appointment_ID;
            END IF;
        END;
    END Schedule_Appointment;

    -- Procedure to generate a bill
    PROCEDURE Generate_Bill(
        p_Appointment_ID IN NUMBER,
        p_Amount IN NUMBER,
        p_Payment_Method IN VARCHAR2,
        p_Billing_ID OUT NUMBER
    ) IS
    BEGIN
        INSERT INTO Billing (Appointment_ID, Amount, Payment_Method, Payment_Status)
        VALUES (p_Appointment_ID, p_Amount, p_Payment_Method, 'Pending')
        RETURNING Billing_ID INTO p_Billing_ID;
    END Generate_Bill;

    -- Function to check available slots for a doctor
    FUNCTION Check_Available_Slot(
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP
    ) RETURN VARCHAR2 IS
        v_Count NUMBER;
    BEGIN
        -- Check if the slot is available
        SELECT COUNT(*)
        INTO v_Count
        FROM Appointments
        WHERE Doctor_ID = p_Doctor_ID
        AND Appointment_Date = p_Appointment_Date
        AND Appointment_Time = p_Appointment_Time
        AND Status = 'Scheduled';

        IF v_Count = 0 THEN
            RETURN 'Available';
        ELSE
            RETURN 'Not Available';
        END IF;
    END Check_Available_Slot;

END HMS_PKG;


PACKAGES COMBINED:

CREATE OR REPLACE PACKAGE HMS_PKG IS

    -- Function to get patient details by ID
    FUNCTION Get_Patient_Details(p_Patient_ID IN NUMBER) RETURN SYS_REFCURSOR;

    -- Procedure to schedule an appointment
    PROCEDURE Schedule_Appointment(
        p_Patient_ID IN NUMBER,
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP,
        p_Reason IN VARCHAR2,
        p_Appointment_ID OUT NUMBER
    );

    -- Procedure to generate a bill
    PROCEDURE Generate_Bill(
        p_Appointment_ID IN NUMBER,
        p_Amount IN NUMBER,
        p_Payment_Method IN VARCHAR2,
        p_Billing_ID OUT NUMBER
    );

    -- Function to check available slots for a doctor
    FUNCTION Check_Available_Slot(
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP
    ) RETURN VARCHAR2;

    -- Function to calculate patient age
    FUNCTION Get_Patient_Age(p_Patient_ID IN NUMBER) RETURN NUMBER;

    -- Function to calculate running total of payments
    FUNCTION Get_Running_Total_Payments(p_Patient_ID IN NUMBER) RETURN SYS_REFCURSOR;

    -- Function to rank doctors by appointments
    FUNCTION Get_Doctor_Rankings RETURN SYS_REFCURSOR;

    -- Function to calculate average appointment duration for each doctor
    FUNCTION Get_Average_Appointment_Duration RETURN SYS_REFCURSOR;

END HMS_PKG;

CREATE OR REPLACE PACKAGE BODY HMS_PKG IS

    -- Function to get patient details
    FUNCTION Get_Patient_Details(p_Patient_ID IN NUMBER) RETURN SYS_REFCURSOR IS
        v_Cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_Cursor FOR
        SELECT *
        FROM Patients
        WHERE Patient_ID = p_Patient_ID;
        
        RETURN v_Cursor;
    END Get_Patient_Details;

    -- Procedure to schedule an appointment
    PROCEDURE Schedule_Appointment(
        p_Patient_ID IN NUMBER,
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP,
        p_Reason IN VARCHAR2,
        p_Appointment_ID OUT NUMBER
    ) IS
    BEGIN
        -- Check for overlapping appointments
        DECLARE
            v_count NUMBER;
        BEGIN
            SELECT COUNT(*)
            INTO v_count
            FROM Appointments
            WHERE Doctor_ID = p_Doctor_ID
            AND Appointment_Date = p_Appointment_Date
            AND Appointment_Time = p_Appointment_Time
            AND Status = 'Scheduled';

            IF v_count > 0 THEN
                RAISE_APPLICATION_ERROR(-20001, 'Overlapping appointment exists for the doctor.');
            ELSE
                INSERT INTO Appointments (Patient_ID, Doctor_ID, Appointment_Date, Appointment_Time, Status, Reason)
                VALUES (p_Patient_ID, p_Doctor_ID, p_Appointment_Date, p_Appointment_Time, 'Scheduled', p_Reason)
                RETURNING Appointment_ID INTO p_Appointment_ID;
            END IF;
        END;
    END Schedule_Appointment;

    -- Procedure to generate a bill
    PROCEDURE Generate_Bill(
        p_Appointment_ID IN NUMBER,
        p_Amount IN NUMBER,
        p_Payment_Method IN VARCHAR2,
        p_Billing_ID OUT NUMBER
    ) IS
    BEGIN
        INSERT INTO Billing (Appointment_ID, Amount, Payment_Method, Payment_Status)
        VALUES (p_Appointment_ID, p_Amount, p_Payment_Method, 'Pending')
        RETURNING Billing_ID INTO p_Billing_ID;
    END Generate_Bill;

    -- Function to check available slots for a doctor
    FUNCTION Check_Available_Slot(
        p_Doctor_ID IN NUMBER,
        p_Appointment_Date IN DATE,
        p_Appointment_Time IN TIMESTAMP
    ) RETURN VARCHAR2 IS
        v_Count NUMBER;
    BEGIN
        -- Check if the slot is available
        SELECT COUNT(*)
        INTO v_Count
        FROM Appointments
        WHERE Doctor_ID = p_Doctor_ID
        AND Appointment_Date = p_Appointment_Date
        AND Appointment_Time = p_Appointment_Time
        AND Status = 'Scheduled';

        IF v_Count = 0 THEN
            RETURN 'Available';
        ELSE
            RETURN 'Not Available';
        END IF;
    END Check_Available_Slot;

    -- Function to calculate patient age
    FUNCTION Get_Patient_Age(p_Patient_ID IN NUMBER) RETURN NUMBER IS
        v_Date_Of_Birth DATE;
        v_Age NUMBER;
    BEGIN
        SELECT Date_Of_Birth
        INTO v_Date_Of_Birth
        FROM Patients
        WHERE Patient_ID = p_Patient_ID;

        v_Age := FLOOR(MONTHS_BETWEEN(SYSDATE, v_Date_Of_Birth) / 12);

        RETURN v_Age;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL; -- Return NULL if patient not found
    END Get_Patient_Age;

    -- Function to calculate running total of payments for a patient
    FUNCTION Get_Running_Total_Payments(p_Patient_ID IN NUMBER) RETURN SYS_REFCURSOR IS
        v_Cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_Cursor FOR
        SELECT 
            Patient_ID,
            Billing_ID,
            Payment_Date,
            Amount,
            SUM(Amount) OVER (PARTITION BY Patient_ID ORDER BY Payment_Date) AS Running_Total
        FROM 
            Billing
        WHERE 
            Patient_ID = p_Patient_ID
        ORDER BY 
            Payment_Date;

        RETURN v_Cursor;
    END Get_Running_Total_Payments;

    -- Function to rank doctors by number of appointments
    FUNCTION Get_Doctor_Rankings RETURN SYS_REFCURSOR IS
        v_Cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_Cursor FOR
        SELECT 
            Doctor_ID,
            First_Name,
            Last_Name,
            COUNT(Appointment_ID) AS Total_Appointments,
            RANK() OVER (ORDER BY COUNT(Appointment_ID) DESC) AS Doctor_Rank
        FROM 
            Doctors d
        JOIN 
            Appointments a ON d.Doctor_ID = a.Doctor_ID
        GROUP BY 
            Doctor_ID, First_Name, Last_Name
        ORDER BY 
            Doctor_Rank;

        RETURN v_Cursor;
    END Get_Doctor_Rankings;

    -- Function to calculate average appointment duration for each doctor
    FUNCTION Get_Average_Appointment_Duration RETURN SYS_REFCURSOR IS
        v_Cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_Cursor FOR
        SELECT 
            Doctor_ID,
            First_Name,
            Last_Name,
            AVG(Appointment_Duration) OVER (PARTITION BY Doctor_ID) AS Average_Duration
        FROM 
            (SELECT 
                a.Doctor_ID,
                d.First_Name,
                d.Last_Name,
                EXTRACT(MINUTE FROM (End_Time - Start_Time)) AS Appointment_Duration
            FROM 
                Appointments a
            JOIN 
                Doctors d ON a.Doctor_ID = d.Doctor_ID
            WHERE 
                a.Status = 'Completed') 
        ORDER BY 
            Doctor_ID;

        RETURN v_Cursor;
    END Get_Average_Appointment_Duration;

END HMS_PKG;


Developing a Health Management System (HMS) web application using Oracle APEX (Application Express) can be an efficient way to leverage Oracle’s powerful database capabilities alongside a low-code development environment. Oracle APEX is ideal for building scalable, secure, and responsive web applications, especially those requiring advanced database interactions.
Key Steps for Developing a Health Management System in Oracle APEX
Set Up the Oracle APEX Environment:
Ensure that you have access to an Oracle APEX environment. This can be on-premises, on Oracle Cloud, or via a free workspace on the APEX Oracle website.
Set up your workspace, schema, and initial database objects (tables, sequences, etc.) required for the HMS.
Define Database Schema:
Create tables for essential entities such as Patients, Doctors, Appointments, Billing, and more. Ensure that primary keys, foreign keys, and other constraints are properly defined.
Use SQL scripts or the SQL Workshop in APEX to create the tables, views, triggers, and packages. For example:
sql
Copy code
CREATE TABLE Patients (
    Patient_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    First_Name VARCHAR2(50),
    Last_Name VARCHAR2(50),
    Date_Of_Birth DATE,
    Gender VARCHAR2(10),
    Phone_Number VARCHAR2(15),
    Email VARCHAR2(100),
    Address VARCHAR2(255)
);

CREATE TABLE Doctors (
    Doctor_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    First_Name VARCHAR2(50),
    Last_Name VARCHAR2(50),
    Specialization VARCHAR2(100),
    Phone_Number VARCHAR2(15),
    Email VARCHAR2(100)
);

CREATE TABLE Appointments (
    Appointment_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Patient_ID NUMBER,
    Doctor_ID NUMBER,
    Appointment_Date DATE,
    Appointment_Time TIMESTAMP,
    Status VARCHAR2(20),
    Reason VARCHAR2(255),
    FOREIGN KEY (Patient_ID) REFERENCES Patients(Patient_ID),
    FOREIGN KEY (Doctor_ID) REFERENCES Doctors(Doctor_ID)
);

CREATE TABLE Billing (
    Billing_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Appointment_ID NUMBER,
    Amount NUMBER(10, 2),
    Payment_Method VARCHAR2(20),
    Payment_Status VARCHAR2(20),
    Payment_Date DATE,
    FOREIGN KEY (Appointment_ID) REFERENCES Appointments(Appointment_ID)
);
